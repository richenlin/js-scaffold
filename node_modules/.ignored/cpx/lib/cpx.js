"use strict";

var _get = require("babel-runtime/helpers/get")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

var _interopRequireWildcard = require("babel-runtime/helpers/interop-require-wildcard")["default"];

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require("events");

var _path = require("path");

var _fs = require("fs");

var _mkdirp = require("mkdirp");

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _minimatch = require("minimatch");

var _glob = require("glob");

var _glob2base = require("glob2base");

var _glob2base2 = _interopRequireDefault(_glob2base);

var _chokidar = require("chokidar");

var _copy = require("./copy");

var cp = _interopRequireWildcard(_copy);

var _utils = require("./utils");

var _queue = require("./queue");

var _queue2 = _interopRequireDefault(_queue);

var SOURCE = _Symbol("source");
var OUT_DIR = _Symbol("outDir");
var TRANSFORM = _Symbol("transform");
var QUEUE = _Symbol("queue");
var WATCHER = _Symbol("watcher");

// Glob is not supported delimiters of Windows.
function normalizePath(path) {
  if (path == null) {
    return null;
  }
  path = path.replace(/\\/g, "/").trim();
  if (/\/$/.test(path)) {
    path = path.slice(0, -1);
  }
  return path;
}

// Call the action for every files that matches the pattern.
function doAllSimply(cpx, pattern, action) {
  new _glob.Glob(pattern, { nodir: true, silent: true }).on("match", action.bind(cpx));
}

// Call the action for every files that matches the pattern.
function doAll(cpx, pattern, action, cb) {
  if (cb == null) {
    doAllSimply(cpx, pattern, action);
    return;
  }

  var count = 0;
  var done = false;
  var lastError = null;
  var cbIfEnd = function cbIfEnd() {
    if (done && count === 0) {
      cb(lastError);
    }
  };

  new _glob.Glob(pattern, { nodir: true, silent: true }).on("match", function (path) {
    if (lastError != null) {
      return;
    }

    count += 1;
    action.call(cpx, path, function (err) {
      count -= 1;
      lastError = lastError || err;
      cbIfEnd();
    });
  }).on("end", function () {
    done = true;
    cbIfEnd();
  }).on("error", function (err) {
    lastError = lastError || err;
  });
}

var Cpx = (function (_EventEmitter) {
  _inherits(Cpx, _EventEmitter);

  /**
   * @param {string} source - A blob for copy files.
   * @param {string} outDir - A file path for the destination directory.
   */

  function Cpx(source, outDir, options) {
    _classCallCheck(this, Cpx);

    (0, _utils.assertType)(source, "source", "string");
    (0, _utils.assertType)(outDir, "outDir", "string");
    _get(Object.getPrototypeOf(Cpx.prototype), "constructor", this).call(this);

    var transforms = [].concat(options && options.transform).filter(Boolean);
    transforms.forEach(function (t) {
      return (0, _utils.assertType)(t, "transform", "function");
    });

    this[SOURCE] = normalizePath(source);
    this[OUT_DIR] = normalizePath(outDir);
    this[TRANSFORM] = transforms;
    this[QUEUE] = new _queue2["default"]();
    this[WATCHER] = null;
  }

  _createClass(Cpx, [{
    key: "src2dst",

    /**
     * Convert a glob from source to destination.
     * @param {string} path
     * @returns {string}
     */
    value: function src2dst(path) {
      (0, _utils.assertType)(path, "path", "string");
      if (this.base === ".") {
        return (0, _path.join)(this.outDir, path);
      }
      return path.replace(this.base, this.outDir);
    }
  }, {
    key: "enqueueCopy",

    /**
     * Copy a file sequentially.
     * @param {string} srcPath
     * @param {cpx~callback} [cb = null]
     */
    value: function enqueueCopy(srcPath) {
      var _this = this;

      var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      (0, _utils.assertType)(srcPath, "srcPath", "string");
      (0, _utils.assertTypeOpt)(cb, "cb", "function");

      var dstPath = this.src2dst(srcPath);
      if (dstPath === srcPath) {
        if (cb != null) {
          setImmediate(cb, null);
          return;
        }
      }

      this[QUEUE].push(function (next) {
        (0, _mkdirp2["default"])((0, _path.dirname)(dstPath), next);
      });
      this[QUEUE].push(function (next) {
        cp.copy(srcPath, dstPath, _this.transformFactories, function (err) {
          if (err == null) {
            _this.emit("copy", { srcPath: srcPath, dstPath: dstPath });
          }

          next();
          if (cb != null) {
            cb(err || null);
          }
        });
      });
    }
  }, {
    key: "enqueueRemove",

    /**
     * Remove a file sequentially.
     * @param {string} path
     * @param {cpx~callback} [cb = null]
     */
    value: function enqueueRemove(path) {
      var _this2 = this;

      var cb = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      (0, _utils.assertType)(path, "path", "string");
      (0, _utils.assertTypeOpt)(cb, "cb", "function");

      var lastError = null;
      this[QUEUE].push(function (next) {
        (0, _fs.unlink)(path, function (err) {
          if (err == null) {
            _this2.emit("remove", { path: path });
          }

          lastError = err;
          next();
        });
      });
      this[QUEUE].push(function (next) {
        (0, _fs.rmdir)((0, _path.dirname)(path), function () {
          next();
          if (cb != null) {
            cb(lastError);
          }
        });
      });
    }
  }, {
    key: "clean",

    //============================================================================
    // Clean Methods
    //----------------------------------------------------------------------------

    /**
     * Remove all files that matches `this.source` like pattern in `this.dest`
     * directory.
     * @param {cpx~callback} [cb = null]
     */
    value: function clean() {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      (0, _utils.assertTypeOpt)(cb, "cb", "function");

      var dest = this.src2dst(this.source);
      if (dest === this.source) {
        if (cb != null) {
          setImmediate(cb, null);
        }
        return;
      }

      doAll(this, dest, this.enqueueRemove, cb);
    }
  }, {
    key: "cleanSync",

    /**
     * Remove all files that matches `this.source` like pattern in `this.dest`
     * directory.
     * @thrpws {Error} IO error.
     */
    value: function cleanSync() {
      var _this3 = this;

      var dest = this.src2dst(this.source);
      if (dest === this.source) {
        return;
      }

      var pathes = (0, _glob.sync)(dest, { nodir: true, silent: true });
      pathes.forEach(function (path) {
        (0, _fs.unlinkSync)(path);
        try {
          (0, _fs.rmdirSync)((0, _path.dirname)(path));
        } catch (err) {
          if (err.code !== "ENOTEMPTY") {
            throw err;
          }
        }
        _this3.emit("remove", { path: path });
      });
    }
  }, {
    key: "copy",

    //============================================================================
    // Copy Methods
    //----------------------------------------------------------------------------

    /**
     * Copy all files that matches `this.source` pattern to `this.outDir`.
     * @param {cpx~callback} [cb = null]
     */
    value: function copy() {
      var cb = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      (0, _utils.assertTypeOpt)(cb, "cb", "function");
      doAll(this, this.source, this.enqueueCopy, cb);
    }
  }, {
    key: "copySync",

    /**
     * Copy all files that matches `this.source` pattern to `this.outDir`.
     * @thrpws {Error} IO error.
     */
    value: function copySync() {
      var _this4 = this;

      (0, _utils.assert)(this.transformFactories.length === 0, "Synchronous copy can't use the transform option.");

      var srcPathes = (0, _glob.sync)(this.source, { nodir: true, silent: true });
      srcPathes.forEach(function (srcPath) {
        var dstPath = _this4.src2dst(srcPath);
        if (dstPath === srcPath) {
          return; //continue
        }

        (0, _mkdirp.sync)((0, _path.dirname)(dstPath));
        cp.copySync(srcPath, dstPath);

        _this4.emit("copy", { srcPath: srcPath, dstPath: dstPath });
      });
    }
  }, {
    key: "watch",

    //============================================================================
    // Watch Methods
    //----------------------------------------------------------------------------

    /**
     * Copy all files that matches `this.source` pattern to `this.outDir`.
     * And watch changes in `this.base`, and copy only the file every time.
     * @throws {Error} This had been watching already.
     */
    value: function watch() {
      var _this5 = this;

      if (this[WATCHER] != null) {
        throw new Error("InvalidStateError");
      }

      var m = new _minimatch.Minimatch(this.source);
      var firstCopyCount = 0;
      var ready = false;
      var fireReadyIfReady = function fireReadyIfReady() {
        if (ready && firstCopyCount === 0) {
          _this5.emit("watch-ready");
        }
      };

      this[WATCHER] = (0, _chokidar.watch)(this.base, { cwd: process.cwd(), persistent: true }).on("add", function (path) {
        path = normalizePath(path);
        if (m.match(path)) {
          if (ready) {
            _this5.enqueueCopy(path);
          } else {
            firstCopyCount += 1;
            _this5.enqueueCopy(path, function () {
              firstCopyCount -= 1;
              fireReadyIfReady();
            });
          }
        }
      }).on("unlink", function (path) {
        path = normalizePath(path);
        if (m.match(path)) {
          var dstPath = _this5.src2dst(path);
          if (dstPath !== path) {
            _this5.enqueueRemove(dstPath);
          }
        }
      }).on("change", function (path) {
        path = normalizePath(path);
        if (m.match(path)) {
          _this5.enqueueCopy(path);
        }
      }).on("ready", function () {
        ready = true;
        fireReadyIfReady();
      }).on("error", function (err) {
        _this5.emit("watch-error", err);
      });
    }
  }, {
    key: "unwatch",

    /**
     * Stop watching.
     */
    value: function unwatch() {
      if (this[WATCHER] != null) {
        this[WATCHER].close();
        this[WATCHER] = null;
      }
    }
  }, {
    key: "close",

    /**
     * Stop watching.
     */
    value: function close() {
      this.unwatch();
    }
  }, {
    key: "source",

    //============================================================================
    // Commons
    //----------------------------------------------------------------------------

    /**
     * The source file glob to copy.
     * @type {string}
     */
    get: function get() {
      return this[SOURCE];
    }
  }, {
    key: "outDir",

    /**
     * The destination directory to copy.
     * @type {string}
     */
    get: function get() {
      return this[OUT_DIR];
    }
  }, {
    key: "transformFactories",

    /**
     * The factories of transform streams.
     * @type {function[]}
     */
    get: function get() {
      return this[TRANSFORM];
    }
  }, {
    key: "base",

    /**
     * The base directory of `this.source`.
     * @type {string}
     */
    get: function get() {
      var value = normalizePath((0, _glob2base2["default"])(new _glob.Glob(this.source)));
      Object.defineProperty(this, "base", { value: value, configurable: true });
      return value;
    }
  }]);

  return Cpx;
})(_events.EventEmitter);

exports["default"] = Cpx;
module.exports = exports["default"];