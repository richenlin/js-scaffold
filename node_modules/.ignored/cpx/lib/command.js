#!/usr/bin/env node


/*eslint no-process-exit:0*/
"use strict";

var _Set = require("babel-runtime/core-js/set")["default"];

var _Object$keys = require("babel-runtime/core-js/object/keys")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

var _fs = require("fs");

var _path = require("path");

var _child_process = require("child_process");

var _resolve = require("resolve");

var _shellQuote = require("shell-quote");

var _duplexer = require("duplexer");

var _duplexer2 = _interopRequireDefault(_duplexer);

var _subarg = require("subarg");

var _subarg2 = _interopRequireDefault(_subarg);

var _cpx = require("./cpx");

var _cpx2 = _interopRequireDefault(_cpx);

var HELP_TEXT = "\nUsage: cpx <source> <dest> [options]\n\n  Copy file globs, watching for changes.\n\n    <source>  A file glob of target files.\n              e.g. src/**/*.{html,png,jpg}\n    <dest>    A path of destination directory.\n              e.g. app\n\nOptions:\n\n  -c, --command <command>   A command text to transform each file.\n  -C, --clean               Clean files that matches <source> like pattern in\n                            <dest> directory before the first copying.\n  -h, --help                Print usage information\n  -t, --transform <name>    A module name to transform each file. cpx lookups\n                            the specified name via \"require()\".\n  -v, --verbose             Print copied/removed files.\n  -V, --version             Print the version number\n  -w, --watch               Watch for files that matches <source>, and copy the\n                            file to <dest> every changing.\n\nSee Also:\n  https://github.com/mysticatea/cpx\n";

// {Shorname: Fullname}
var OPTIONS = {
  "c": "command",
  "C": "clean",
  "h": "help",
  "t": "transform",
  "v": "verbose",
  "V": "version",
  "w": "watch"
};

//------------------------------------------------------------------------------
// Parse arguments.
var args = (0, _subarg2["default"])(process.argv.slice(2), {
  boolean: ["clean", "help", "verbose", "version", "watch"],
  alias: OPTIONS
});

//------------------------------------------------------------------------------
// Validate Options.
var knowns = new _Set(["_"]);
for (var key in OPTIONS) {
  knowns.add(key);
  knowns.add(OPTIONS[key]);
}
var unknowns = _Object$keys(args).filter(function (key) {
  return !knowns.has(key);
});
if (unknowns.length > 0) {
  console.error("Unknown option(s): " + unknowns.join(", "));
  process.exit(1);
}

//------------------------------------------------------------------------------
// Help/Version.
if (args.help) {
  console.log(HELP_TEXT);
  process.exit(0);
}
if (args.version) {
  var version = JSON.parse((0, _fs.readFileSync)((0, _path.join)(__dirname, "../package.json"))).version;
  console.log("v" + version);
  process.exit(0);
}

//------------------------------------------------------------------------------
// Validate Arguments.
var source = args._[0];
var outDir = args._[1];
if (source == null || outDir == null || args._.length > 2) {
  console.log(HELP_TEXT);
  process.exit(1);
}

//------------------------------------------------------------------------------
// Resolve Command.
var commands = [].concat(args.command).filter(Boolean).map(function (command) {
  if (typeof command !== "string") {
    console.error("Invalid --command option");
    process.exit(1);
  }
  return function (file) {
    var env = _Object$create(process.env, { FILE: { value: file } });
    var parts = (0, _shellQuote.parse)(command, env);
    var child = (0, _child_process.spawn)(parts[0], parts.slice(1), { env: env });
    var outer = (0, _duplexer2["default"])(child.stdin, child.stdout);
    child.on("exit", function (code) {
      if (code !== 0) {
        outer.emit("error", new Error("non-zero exit code in command: " + command));
      }
    });
    child.stderr.pipe(process.stderr);

    return outer;
  };
});

//------------------------------------------------------------------------------
// Resolve Transforms.
var ABS_OR_REL = /^[.\/]/;
var transforms = [].concat(args.transform).filter(Boolean).map(function (arg) {
  if (typeof arg === "string") {
    return { name: arg, argv: null };
  }
  if (typeof arg._[0] === "string") {
    return { name: arg._.shift(), argv: arg };
  }
  console.error("Invalid --transform option");
  process.exit(1);
}).map(function (item) {
  var createStream = ABS_OR_REL.test(item.name) ? require((0, _path.resolve)(item.name)) : require((0, _resolve.sync)(item.name, { basedir: process.cwd() }));
  return function (file) {
    return createStream(file, item.argv);
  };
});

//------------------------------------------------------------------------------
// Merge commands and transforms as same as order of process.argv.
var C_OR_COMMAND = /^(?:-c|--command)$/;
var T_OR_TRANSFORM = /^(?:-t|--transform)$/;
var mergedTransformFactories = process.argv.map(function (part) {
  if (C_OR_COMMAND.test(part)) {
    return commands.shift();
  }
  if (T_OR_TRANSFORM.test(part)) {
    return transforms.shift();
  }
  return null;
}).filter(Boolean);

//------------------------------------------------------------------------------
// Main.
var cpx = new _cpx2["default"](source, outDir, { transform: mergedTransformFactories });
if (args.verbose) {
  cpx.on("copy", function (e) {
    console.log("Copied: " + e.srcPath + " --> " + e.dstPath);
  });
  cpx.on("remove", function (e) {
    console.log("Removed: " + e.path);
  });
}

if (args.clean) {
  if (args.verbose) {
    console.log();
    console.log("Clean: " + cpx.src2dst(cpx.source));
    console.log();
  }
  try {
    cpx.cleanSync();
  } catch (err) {
    console.error("Failed to clean: " + err.message + ".");
    process.exit(1);
  }
  if (args.verbose) {
    console.log();
    console.log("Copy: " + source + " --> " + outDir);
    console.log();
  }
}

if (args.watch) {
  if (args.verbose) {
    cpx.on("watch-ready", function () {
      console.log();
      console.log("Be watching in " + cpx.base);
      console.log();
    });
  }
  cpx.on("watch-error", function (err) {
    console.error(err.message);
  });

  // In order to kill me by test harness on Windows.
  process.stdin.setEncoding("utf8");
  process.stdin.on("data", function (chunk) {
    if (chunk === "KILL") {
      process.exit(0);
    }
  });

  cpx.watch();
} else {
  cpx.copy(function (err) {
    if (err) {
      console.error("Failed to copy: " + err.message + ".");
      process.exit(1);
    }
  });
}